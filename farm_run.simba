{$include_once WaspLib/osr/handlers/teleports/transport.simba}

type
  EFarmPatch = (
    WEISS_HERB,
    STRONGHOLD_HERB,
    CATHERBY_HERB,
    CATHERBY_ALLOT_N,
    ARDY_HERB,
    HOSIDIOUS_HERB,
    HOSIDIOUS_FLOWER,
    FALLY_HERB,
    PHASMATYS_HERB,
    GUILD_HERB,
    MONESTARY_BUSH
  );

  ETravelMethod = (
   ICY_BASALT,            {Weiss}
   STONY_BASALT,          {Troll Stronghold}
   CATHERBY_TABLET,       {Catherby}
   CATHERBY_TELEPORT,     {Catherby}
   CAMELOT_TELEPORT,      {Catherby}
   CAMELOT_TABLET,        {Catherby}
   ARDY_CLOAK_2,          {Ardy}
   ARDY_CLOAK_3,          {Ardy}
   ARDY_CLOAK_4,          {Ardy}
   ARDY_CLOAK_2_BUSH,     {Monastery}
   ARDY_CLOAK_3_BUSH,     {Monastery}
   ARDY_CLOAK_4_BUSH,     {Monastery}
   XERICS_TALISMAN,       {Hosidious}
   HOSIDIOUS_TABLET,      {Hosidious}
   HOUSE_TELEPORT,        {Hosidious}
   EXPLORERS_RING_2,      {Fally}
   EXPLORERS_RING_3,      {Fally}
   EXPLORERS_RING_4,      {Fally}
   FENKENSTRAIN_TELEPORT, {Phasmatys}
   ECTOPHIAL,             {Phasmatys}
   FARMING_CAPE,          {Guild}
   HOUSE_TAB_SPIRIT_TREE_GUILD,
   HOUSE_TELE_SPIRIT_TREE_GUILD
  );

  ECompostMethod = (
    REGULAR,
    SUPER,
    ULTRA,
    BOTTOMLESS,
    FERTILE_SOIL
  );

  EPatchType = (
    HERB,
    FLOWER,
    BUSH,
    ALLOTMENT
  );

  EPatchState = (
    TELEPORT_TO,
    DEAD,
    DISEASED,
    HARVEST,
    PLANT,
    COMPOST,
    NOTE_ITEMS,
    FAILED,
    COMPLETE,
    SKIP,
    HARVEST_WHITEBERRIES
  );

  TFarmContract = record
    Seed                            : TRSItem;
    GrowTimer                       : TCountdown;
  end;

  TPatchData = record
    PatchType                       : EPatchType;
    BorderColor, SoilColor          : TCTS2Color;
    Coords, LeprechaunCoords        : TPoint;
    LeprechaunColor                 : TCTS2Color;
    Name                            : String;
    MapCoords                       : TBox;
  end;

  TFarmPatch = record
    Data                            : TPatchData;
    TPA                             : TPointArray;
    SearchBox                       : TBox;
    TravelMethod                    : ETravelMethod;
    Seed                            : TRSItem;
    EmptyUpText                     : String;
    PlantedUpText                   : String;
    HarvestUpText                   : String;
    RSW                             : PRSWalker;
    Complete                        : Boolean;
    Skip                            : Boolean;
  end;

  TFarmRun = record
    Patches                         : array of TFarmPatch;
    CurrentPatch                    : TFarmPatch;
    InactivityTimer                 : TCountdown;
    RSW                             : TRSWalker;
    PatchesCompleted                : Int32;
    PatchesSkipped                  : Int32;
    ResurrectCrop                   : Boolean;
    CompostMethod                   : ECompostMethod;

    MaxRuns                         : Int32;
    RunsComplete                    : Int32;
    Runtime                         : TStopWatch;
    HarvestQuantities               : TIntegerArray;
    XPGained, LastXPRead            : Int32;
    OnStart, OnComplete             : procedure();
    DoReport, DoBreak               : Boolean;
    Transport                       : TUniversalTransport;
    ReadyTimer                      : TCountDown;
  end;

const
  GRIMY_HERBS       : TRSItemArray := [
    'Grimy guam leaf', 'Grimy marrentill',
    'Grimy tarromin', 'Grimy harralander',
    'Grimy ranarr weed', 'Grimy toadflax',
    'Grimy irit leaf', 'Grimy avantoe',
    'Grimy kwuarm', 'Grimy snapdragon',
    'Grimy cadantine', 'Grimy lantadyme',
    'Grimy dwarf weed', 'Grimy torstol'
    ];

  LEPRECHAUN_ITEMS  : TRSItemArray := [
    'Guam leaf', 'Marrentill',
    'Tarromin', 'Harralander',
    'Ranarr weed', 'Toadflax',
    'Irit leaf', 'Avantoe',
    'Kwuarm', 'Snapdragon',
    'Cadantine', 'Lantadyme',
    'Dwarf weed', 'Torstol',
    'Limpwurt root', 'Snape grass',
    'White berries', 'Potato cactus'
    ];

  CONTRACT_TEXT     : TStringArray = [
    'torstol', 'dwarf weed', 'lantadyme', 'cadantine', 'snapdragon',
    'kwuarm', 'avantoe', 'irit', 'toadflax', 'ranarr', 'harralander',
    'tarromin', 'marrentill', 'guam',

    'magic', 'yew', 'maple', 'willow', 'oak',

    'white lily', 'limpwurt', 'woad', 'nasturtium', 'rosemary', 'marigold',

    'poison ivy', 'white berry', 'jangerberry', 'dwellberry', 'cadavaberry',
    'redberry',

    'snape grass', 'watermelon', 'strawberr', 'sweetcorn', 'tomatoe',
    'cabbage', 'onion', 'potatoe',

    'potato cacti', 'cacti',

    'celastrus',

    'dragonfruit', 'palm', 'papaya', 'pineapple', 'curry', 'orange',
    'banana', 'apple',

    'redwood'
  ];

var
  PatchData                         : array of TPatchData;

begin

  PatchData += [    {Weiss/herb}
      {patch type}        EPatchType.HERB,
      {border color}      CTS2(6520971, 8, 0.05, 0.27),
      {soil color}        CTS2(408653, 7, 0.11, 2.64),
      {patch coords}      [6786, 709],
      {leprechaun coords} [6784, 727],
      {leprechaun color}  CTS2(3108159, 13, 0.08, 1.39),
      {name}              'Weiss herb',
      {map coords}        [6500,  600, 7000,  800]];

  PatchData += [    {Stronghold/herb}
      {patch type}        EPatchType.HERB,
      {border color}      CTS2(5927804, 9, 0.05, 0.11),
      {soil color}        CTS2(408653, 7, 0.11, 2.64),
      {patch coords}      [6699, 1670],
      {leprechaun coords} [6697, 1704],
      {leprechaun color}  CTS2(3830139, 13, 0.03, 0.44),
      {name}              'Stronghold herb',
      {map coords}        [6550, 1550, 6850, 1800]];

  PatchData += [    {Catherby/herb}
      {patch type}        EPatchType.HERB,
      {border color}      CTS2(5927804, 9, 0.05, 0.11),
      {soil color}        CTS2(2970201, 11, 0.05, 0.25),
      {patch coords}      [6646, 2594],
      {leprechaun coords} [6653, 2583],
      {leprechaun color}  CTS2(3108159, 13, 0.08, 1.39),
      {name}              'Catherby herb',
      {map coords}        [6286, 2351, 6910, 2850]];

  PatchData += [    {Catherby/snape}
      {patch type}        EPatchType.ALLOTMENT,
      {border color}      CTS2(5927804, 9, 0.05, 0.11),
      {soil color}        CTS2(3431524, 12, 0.05, 0.16),
      {patch coords}      [6644, 2578],
      {leprechaun coords} [6653, 2583],
      {leprechaun color}  CTS2(3108159, 13, 0.08, 1.39),
      {name}              'Catherby allotment',
      {map coords}        [6286, 2351, 6910, 2850]];

  PatchData += [    {Ardy/herb}
      {patch type}        EPatchType.HERB,
      {border color}      CTS2(5927804, 9, 0.05, 0.11),
      {soil color}        CTS2(2970201, 11, 0.05, 0.25),
      {patch coords}      [6075, 2949],
      {leprechaun coords} [6080, 2923],
      {leprechaun color}  CTS2(3108159, 13, 0.08, 1.39),
      {name}              'Ardy herb',
      {map coords}        [5900, 2800, 6250, 3100]];

  PatchData += [    {Hosidious/herb}
      {patch type}        EPatchType.HERB,
      {border color}      CTS2(6127499, 6, 0.10, 0.71),
      {soil color}        CTS2(2970201, 11, 0.05, 0.25),
      {patch coords}      [2346, 2258],
      {leprechaun coords} [2357, 2252],
      {leprechaun color}  CTS2(3108159, 13, 0.08, 1.39),
      {name}              'Hosidious herb',
      {map coords}        [2150, 2050, 2600, 2600]];

  PatchData += [    {Hosidious/limp}
      {patch type}        EPatchType.FLOWER,
      {border color}      CTS2(5927804, 9, 0.05, 0.11),
      {soil color}        CTS2(2970201, 11, 0.05, 0.25),
      {patch coords}      [2331, 2242],
      {leprechaun coords} [2357, 2252],
      {leprechaun color}  CTS2(3108159, 13, 0.08, 1.39),
      {name}              'Hosidious flower',
      {map coords}        [2150, 2050, 2600, 2600]];

  PatchData += [    {Fally/herb}
      {patch type}        EPatchType.HERB,
      {border color}      CTS2(5927804, 9, 0.05, 0.11),
      {soil color}        CTS2(2970201, 11, 0.05, 0.25),
      {patch coords}      [7626, 3202],
      {leprechaun coords} [7604, 3228],
      {leprechaun color}  CTS2(3108159, 13, 0.08, 1.39),
      {name}              'Fally herb',
      {map coords}        [7500, 3100, 7700, 3450]];

  PatchData += [    {Phasmatys/herb}
      {patch type}        EPatchType.HERB,
      {border color}      CTS2(2646105, 4, 0.14, 0.45),
      {soil color}        CTS2(2970201, 11, 0.05, 0.25),
      {patch coords}      [9814, 2330],
      {leprechaun coords} [9780, 2359],
      {leprechaun color}  CTS2(2782782, 5, 0.13, 1.58),
      {name}              'Port Phasmatys herb',
      {map coords}        [9385, 2036, 10384, 2680]];

  PatchData += [    {Guild/herb}
      {patch type}        EPatchType.HERB,
      {border color}      CTS2(6319989, 9, 0.10, 0.09),
      {soil color}        CTS2(3762031, 9, 0.08, 0.16),
      {patch coords}      [346, 1554],
      {leprechaun coords} [336, 1532],
      {leprechaun color}  CTS2(2782782, 5, 0.13, 1.58),
      {name}              'Farming Guild herb',
      {map coords}        [ 200, 1300,  600, 1700]];

  PatchData += [    {Monestary/bush}
      {patch type}        EPatchType.BUSH,
      {border color}      CTS2(6127499, 7, 0.08, 0.61),
      {soil color}        CTS2(3497831, 7, 0.07, 0.20),
      {patch coords}      [5864, 3546],
      {leprechaun coords} [5846, 3544],
      {leprechaun color}  CTS2(2782782, 5, 0.13, 1.58),
      {name}              'Monestary bush',
      {map coords}        [5650, 3350, 6050, 3750]];

end;

function ProgReport(
                           ResultType:int32; ScriptName, ScriptAuthor, ScriptVersion: String;
                           varNames: TStringArray;
                           varValues: TvariantArray
                          ): variant;
var
  TSA        : TStringArray;
  s,s2       : String;
  s3         : String := '=';
  s4         : String := ' ';
  i, i2, L   : Int32;
begin
  if (ResultType = 2) then
    Result := '';

  if length(varNames) <> Length(varValues) then
  begin
    Writeln('varNames and varValues must be the same length');
    exit;
  end;
  SetLength(TSA, 3 + Length(varNames) + 4);
  s2 := 'by '+ScriptAuthor;

  TSA[0] := s3;
  TSA[1] := ScriptName.Capitalize+' '+ScriptVersion;
  TSA[2] := s2;
  TSA[3] := s3;

  i2 := 3 + Length(varNames);

  for i:= 4 to i2 do
    L := Max(L, Length(varNames[i-4]));

  for i:= 4 to i2 do
  begin
    s := varValues[i-4];
    TSA[i] := Padr((varNames[i-4]).Capitalize, L)+' : '+ s.Capitalize;
  end;

  TSA[i2+1] := s3;
  TSA[i2+2] := ScriptName.Capitalize+' '+ScriptVersion;
  TSA[i2+3] := s3;

  i2 := 0;
  for i:= 0 to High(TSA) do
    i2 := Max(i2, Length(TSA[i]));

  TSA[0]           := s3.Replicate(i2);
  TSA[3]           := s3.Replicate(i2);
  TSA[High(TSA)-2] := s3.Replicate(i2);
  TSA[High(TSA)]   := s3.Replicate(i2);

  TSA[2] := s4.Replicate(round((i2 - Length(TSA[2]))/2)) + TSA[2]; //centering by ScriptAuthor
  TSA[High(TSA)-1] := s4.Replicate(round((i2 - Length(TSA[High(TSA)-1]))/2)) + TSA[High(TSA)-1];

  for i:= 0 to High(TSA) do
    if (TSA[i][1] = s3) then
      case ResultType of
        0 : writeln     ('[='+Padr(TSA[i], i2)+'=]');
        1 : writeln     ('[='+Padr(TSA[i], i2)+'=]');
        2 : Result := Result + '[='+Padr(TSA[i], i2)+'=]' + chr(13);
        else begin Writeln('Invalid Result Type'); exit; end;
      end
    else
      case ResultType of
        0 : writeln     ('[ '+Padr(TSA[i], i2)+' ]');
        1 : writeln     ('[ '+Padr(TSA[i], i2)+' ]');
        2 : Result := Result + '[ '+Padr(TSA[i], i2)+' ]' + chr(13);
        else begin Writeln('Invalid Result Type'); exit; end;
      end;

  if not ResultType = 2 then Result := true;
end;

procedure TFarmRun.AddPatch(patch: EFarmPatch; travel: ETravelMethod; seed: TRSItem);
var
  emptyUpText   : TStringArray := ['Herb', 'Flower', 'Bush', 'Allotment'];
  harvestUpText : TStringArray := ['Pick', 'Pick', 'Pick', 'Harvest'];
  data : TPatchData := PatchData[patch];
  tpa  : TPointArray := [];
  searchBox : TBox := [0, 0, 0, 0];
  empty : String := emptyUpText[data.PatchType];
  planted : String := ToStr(seed).Before(' ');
  harvest : String := harvestUpText[data.PatchType];
begin
  if data.PatchType = EPatchType.HERB then
    planted := 'Herb';
  Self.Patches += [data, tpa, searchBox, travel, seed,
                   empty, planted, harvest, @Self.RSW];
end;

function TFarmPatch.Find(retry: Boolean = True): Boolean;
var
  attempts        : Int32;

  function F(): Boolean
  var
    borderTPA             : TPointArray;
    borderATPA            : T2DPointArray;
    i                     : Int32;
    filterPt              : TPoint      := Self.RSW^.GetTileMS(Self.Data.Coords).Mean;
  begin
    if not (filterPt in Mainscreen.Bounds) then Exit(False);
    if SRL.FindColors(borderTPA, Self.Data.BorderColor, MainScreen.Bounds) = 0 then
      Exit(False);

    borderATPA := borderTPA.Cluster(Mainscreen.NormalizeDistance(20));
    for i := 0 to High(borderATPA) do begin
      Self.TPA := borderATPA[i].ConvexHull.Connect;
      if SRl.PointInPoly(filterPt, Self.TPA) then begin
        if Self.Data.PatchType = EPatchType.ALLOTMENT then begin
          Self.TPA := Self.TPA.SortFrom(MainScreen.Center);
          Self.TPA := Self.TPA.FilterDist(0, MainScreen.NormalizeDistance(90), Self.TPA[0].X, Self.TPA[0].Y);
        end;
        Self.SearchBox.X1 := (Self.TPA.Mean.X - MainScreen.NormalizeDistance(12));
        Self.SearchBox.Y1 := (Self.TPA.Mean.Y - MainScreen.NormalizeDistance(12));
        Self.SearchBox.X2 := (Self.TPA.Mean.X + MainScreen.NormalizeDistance(12));
        Self.SearchBox.Y2 := (Self.TPA.Mean.Y + MainScreen.NormalizeDistance(12));
        Self.SearchBox.LimitTo(MainScreen.Bounds);
        RSClient.Image.Clear;
        //RSClient.Image.DrawRect(Self.TPA.MinAreaRect, CHAT_COLOR_LIGHT_PURPLE);
        //RSClient.Image.DrawBox(Self.SearchBox, CHAT_COLOR_MAROON);
        Exit(True);
      end;
    end;
    Self.SearchBox := [0, 0, 0, 0];
    Self.TPA := [];
    Result := False;
  end;

begin
  if not retry then
    Exit(F());
  Result := False;
  for attempts := 0 to 3 do begin
    if F() then
      Exit(True);

    case attempts of
      0:    begin
              if not Self.RSW^.MakePointVisible(Self.Data.Coords) then begin
                Self.RSW^.WebWalk([Self.Data.Coords.X + 4, Self.Data.Coords.Y + 4]);
                Self.RSW^.MakePointVisible(Self.Data.Coords);
              end
            end;
      1:    Antiban.RandomRotate;
      2:    begin
              Self.RSW^.WebWalk([Self.Data.Coords.X + 4, Self.Data.Coords.Y + 4]);
              Self.RSW^.MakePointVisible(Self.Data.Coords);
            end;
      3:    begin
              WriteLn('Failed to find patch.');
              Exit;
            end;
    end
  end;
end;

function TFarmPatch.IsDead(): Boolean;
var
  colorCount      : Int32;
begin
  colorCount := SRL.CountColor(CTS2(6050153, 7, 2.73, 0.61), Self.SearchBox);
  Result := colorCount > MainScreen.NormalizeDistance(40);

  //DEBUG
  if colorCount > 0 then
    WriteLn('Found dead patch colors. Count: ', colorCount);
end;

function TFarmPatch.IsDiseased(): Boolean;
var
  colorCount      : Int32;
begin
  //diseasable :=
  colorCount := SRL.CountColor(CTS2(1272942, 14, 0.03, 2.31), Self.SearchBox);
  Result := colorCount > MainScreen.NormalizeDistance(40);

  //DEBUG
  if colorCount > 0 then
    WriteLn('Found diseased patch colors. Count: ', colorCount);
end;

function TFarmPatch.IsEmpty(): Boolean;
var
  colorCount      : Int32;
begin
  colorCount := SRL.CountColor(Self.Data.SoilColor, Self.SearchBox);
  Result := colorCount = Self.SearchBox.Area;
end;

function TFarmPatch.FindLeprechaun(out point: TPoint; retry: Boolean = True): Boolean;
var
  attempts        : Int32;

  function F(): Boolean;
  var
    sortPoint : TPoint := Self.RSW^.GetTileMS(Self.Data.LeprechaunCoords).Mean;
    lepTPA    : TPointArray;
    lepATPA   : T2DPointArray;
  begin
    if not MainScreen.Bounds.Contains(sortPoint) then
      Exit(False);

    if SRL.FindColors(lepTPA, Self.Data.LeprechaunColor, MainScreen.Bounds) = 0 then
      Exit(False);

    lepATPA := lepTPA.Cluster(1).SortFrom(sortPoint);
    point := lepATPA[0].Mean;
    //RSClient.Image.Clear;
    //RSClient.Image.DrawCircle(point, MainScreen.NormalizeDistance(12), CHAT_COLOR_RED);
    Result := True;
  end;

begin
  if not retry then
    Exit(F());
  Result := False;
  for attempts := 0 to 3 do begin
    if F() then
      Exit(True);
    case attempts of
      0:    begin
              if not Self.RSW^.MakePointVisible(Self.Data.LeprechaunCoords) then begin
                Self.RSW^.WebWalk([Self.Data.LeprechaunCoords.X + 4, Self.Data.LeprechaunCoords.Y + 4]);
                Self.RSW^.MakePointVisible(Self.Data.LeprechaunCoords);
              end
            end;
      1:    Antiban.RandomRotate;
      2:    begin
              Self.RSW^.WebWalk([Self.Data.LeprechaunCoords.X + 4, Self.Data.LeprechaunCoords.Y + 4]);
              Self.RSW^.MakePointVisible(Self.Data.LeprechaunCoords);
            end;
      3:    begin
              WriteLn('Failed to find leprechaun.');
              Exit;
            end;
    end
  end;
end;

function TFarmPatch.GetState(): EPatchState;
label
  inspect;
var
  msg : String;
begin
  if not RSClient.IsLoggedIn then
    Exit(EPatchState.FAILED);

  MainScreen.CloseInterface;
  Inventory.SetSelectedSlot(-1);

  if Self.Complete then
    Exit(EPatchState.COMPLETE);
  if Self.Skip then
    Exit(EPatchState.SKIP);

  if Minimap.InPOH then
    Exit(EPatchState.TELEPORT_TO);

  if not (Self.RSW^.GetMyPos in Self.Data.MapCoords) then
    Exit(EPatchState.TELEPORT_TO);

  if not Self.Find then
    Exit(EPatchState.FAILED);

  if Self.Data.PatchType = EPatchType.BUSH then
    Exit(EPatchState.HARVEST_WHITEBERRIES);
  if Self.IsEmpty then
    Exit(EPatchState.PLANT);
  if Self.IsDiseased then
    Exit(EPatchState.DISEASED);
  if Self.IsDead then
    Exit(EPatchState.DEAD);

  if Inventory.IsFull then
    Exit(EPatchState.NOTE_ITEMS);

  if SRL.Dice(65) then
    Mouse.HumanMove(SRL.RandomPoint(Self.TPA.Mean, Mainscreen.NormalizeDistance(15)))
  else
    Mouse.Move(SRL.RandomPoint(Self.TPA.Mean, Mainscreen.NormalizeDistance(15)));

  if Mainscreen.IsUpText(Self.HarvestUpText) then
    Exit(EPatchState.HARVEST);
  if Mainscreen.IsUpText('Dead') then
    Exit(EPatchState.DEAD);
  if Mainscreen.IsUpText('Cure') then
    Exit(EPatchState.DISEASED);
  if MainScreen.IsUpText('Inspect') then begin
    Mouse.Click(MOUSE_LEFT);
    goto inspect;
  end;

  Mouse.Click(MOUSE_RIGHT);
  if ChooseOption.HasOption('Dead') then
    Exit(EPatchState.DEAD);
  if ChooseOption.HasOption(Self.HarvestUpText) then
    Exit(EPatchState.HARVEST);
  if ChooseOption.HasOption('Cure') then
    Exit(EPatchState.DISEASED);
  if ChooseOption.Select('Inspect') then
      goto inspect
  else
    Exit(EPatchState.FAILED);

  inspect:
  if not WaitUntil(Chat.FindMessage('The soil'), 15, 10000) then
    Exit(EPatchState.FAILED);

  msg += Chat.GetMessage(5);
  msg += Chat.GetMessage(6);
  msg += Chat.GetMessage(7);
  msg += Chat.GetMessage(8);

  if msg.Contains('is empty') then
    Exit(EPatchState.PLANT);
  if msg.Contains('not been') then
    Exit(EpatchState.COMPOST);
  if msg.Contains('fully grown') then
    Exit(EPatchState.HARVEST);
  if msg.ContainsAll(['has been', 'growing in it']) then
    Exit(EPatchState.COMPLETE);
  if msg.Contains('dead') then
    Exit(EPatchState.DEAD);
  if msg.Contains('diseas') then
    Exit(EPatchState.DISEASED);
  Exit(EPatchState.FAILED);
end;

function TRSChat.ChatUntilOptions(): Boolean;
var
  Timeout: TCountdown;
begin
  Timeout.Init(10000);
  while (not Timeout.IsFinished) and (not ('Select' in Self.GetChatTitle)) and Self.ClickContinue() do
    Wait(0, 2500, wdLeft);

  Result := 'Select' in Self.GetChatTitle;
end;

{procedure TFarmRun.GetContract();
var
  Jane                    : TRSNPC;
  HasContract,
  FinishedContract,
  GetContract             : Boolean;
  JaneOptions             : TRSChatboxOptionArray;
  CurrentContract         : String;
  i                       : Int32;
begin
  //RSW.Setup([GUILD]);
  //TODO move to WL
  Jane.Setup(['master', 'Jane']);
  Jane.Setup(32, 1, 8, [[384, 1556]]);
  Jane.Finder.Colors += CTS2(7511716, 22, 0.03, 0.43);

  if not (Jane.WalkSelectOption(['Contract'], 1) and WaitUntil(Chat.HasContinue, 15, 10000)) then
    WriteLn('Couldn''t find chat continue');
    //TODO handle this error.

  HasContract := 'current' in Chat.GetChat;
  FinishedContract := 'reward' in Chat.GetChat;
  GetContract := 'kind' in Chat.GetChat;

  Chat.ClickContinue;

  if HasContract then begin
    for i := 0 to High(FarmContracts) do
      if FarmContracts[i].Before(' ') in Chat.GetChat then begin
        CurrentContract := FarmContracts[i];
        Wait(418, 1197);
        Break;
      end;
  end else begin
    if not Chat.ChatUntilOptions then
      WriteLn('Didn''t progress to chat options.');

    JaneOptions := Chat.GetOptions;
    Keyboard.PressKey(JaneOptions[HIGH(JaneOptions)].Number);
    Chat.ClickContinue;
    WaitUntil(('Jane' in Chat.GetChatTitle), 15, 10000);
    for i := 0 to High(FarmContracts) do
      if FarmContracts[i].Before(' ') in Chat.GetChat then begin
        CurrentContract := FarmContracts[i];
        Wait(418, 1197);
        Break;
      end;
  end;

  WriteLn('Contract: ', CurrentContract);
end;}

procedure TFarmRun.CleanGrimyHerbs();
var
  slot            : Int32;
  slots           : TIntegerArray;
begin
  if not RSClient.IsLoggedIn then
    Exit;
  if not Inventory.FindItems(GRIMY_HERBS, slots) then
    Exit;
  for slot in slots do begin
    Mouse.Move(Inventory.GetSlotBox(slot));
    Mouse.Click(MOUSE_LEFT); //TODO Faster click w/ drag
    Wait(32, 56);
  end;
end;

procedure TFarmRun.NoteItems();
var
  count, slot, i  : Int32;
  item            : TRSItem;
  items           : TRSItemArray;
  slots, lepItems : TIntegerArray;
  lepPT           : TPoint;
  playerBox       : TBox;
begin
  if not RSClient.IsLoggedIn then
    Exit;

  Self.CleanGrimyHerbs;

  WriteLn('Noting items at ', '');
  for i:=0 to High(LEPRECHAUN_ITEMS) do begin
    if Inventory.FindItem(item := LEPRECHAUN_ITEMS[i], slot) then begin
      slots += slot;
      items += item;
      lepItems += i;
    end
  end;

  if slots.Len < 1 then
    Exit;

  for i := 0 to High(slots) do begin
    Mainscreen.CloseInterface;

    if Self.RSW.GetMyPos = Self.CurrentPatch.Data.LeprechaunCoords then begin
      playerBox := Mainscreen.GetPlayerBox;
      playerBox.Y1 := playerBox.Y1 - Floor(playerBox.Height / 2);
      lepPT := playerBox.Middle;
    end else if not Self.CurrentPatch.FindLeprechaun(lepPT) then
      Exit;

    count := Inventory.CountItem(items[i]);
    Inventory.SetSelectedSlot(slots[i]);

    if SRL.Dice(65) then
      Mouse.HumanMove(lepPT)
    else
      Mouse.Move(lepPT);

    if Mainscreen.IsUpText('Tool') then begin
      Mouse.Click(MOUSE_LEFT);
    end else if not ChooseOption.Select('Tool') then begin
      WriteLn('Failed to choose option leprechaun.');
      Inventory.SetSelectedSlot(-1);
      Exit;
    end;

    if not Mainscreen.DidRedClick then begin
      WriteLn('Failed to find red click.');
      Inventory.SetSelectedSlot(-1);
      Exit;
    end;

    if SRL.Dice(65) and (i <> High(slots)) then begin
      Wait(187, 317);
      Mouse.Move(Inventory.GetSlotBox(slots[i+1]));
    end else if SRL.Dice(65) then begin
      Mouse.RandomMovement;
    end;

    if WaitUntil((Inventory.CountItem(items[i]) = 0), 15, 10000) then
      Self.HarvestQuantities[lepItems[i]] += count;

    Minimap.WaitPlayerMoving;
  end;
  Inventory.SetSelectedSlot(-1);
end;

procedure TFarmRun.HandleDeadPatch(); begin
  if not RSClient.IsLoggedIn then
    Exit;

  if Self.ResurrectCrop then begin
    case Magic.GetSpellBook of
      ERSSpellBook.ARCEUUS:
        begin
          Magic.ClickSpell(ERSSpell.RESURRECT_CROPS);
          if Chat.FindMessage('to cast') then begin
            Self.ResurrectCrop := False;
            WriteLn('Out of runes for resurrect crop. Disabling.');
          end
        end;
      ERSSpellBook.LUNAR:
        begin
          //TODO spellbook swap
        end;
    end;
  end;

  if Self.ResurrectCrop then
    Wait(16, 53);

  if SRL.Dice(65) then
    Mouse.HumanMove(SRL.RandomPoint(Self.CurrentPatch.TPA.Mean, MainScreen.NormalizeDistance(15)))
  else
    Mouse.Move(SRL.RandomPoint(Self.CurrentPatch.TPA.Mean, MainScreen.NormalizeDistance(15)));

  if MainScreen.IsUpText('Dead') then begin
    Mouse.Click(MOUSE_LEFT);
  end else if not ChooseOption.Select('Dead') then begin
    Mouse.RandomMovement;
    Exit;
  end;

  if not MainScreen.DidRedClick then
    Exit;

  Wait(583, 792);
  Minimap.WaitPlayerMoving;
  Wait(583, 792);

  if not Self.CurrentPatch.Find(False) then
    Exit;

  if not WaitUntil((Chat.FindMessage('restore') or Chat.HasContinue or Self.CurrentPatch.IsEmpty), 15, 15000) then
    Exit;

  if Chat.HasContinue then begin
    if SRL.Dice(65) then
      Mouse.HumanMove(SRL.RandomPoint(Self.CurrentPatch.TPA.Mean, Mainscreen.NormalizeDistance(15)))
    else
      Mouse.Move(SRL.RandomPoint(Self.CurrentPatch.TPA.Mean, Mainscreen.NormalizeDistance(15)));

    if MainScreen.IsUpText('Dead') then begin
      Mouse.Click(MOUSE_LEFT);
    end else if not ChooseOption.Select('Dead') then begin
      Mouse.RandomMovement;
      Exit;
    end;

    if not MainScreen.DidRedClick then
      Exit;

    Wait(583, 792);
    Minimap.WaitPlayerMoving;
    Wait(583, 792);

    if not Self.CurrentPatch.Find(False) then
      Exit;

    WaitUntil((Chat.FindMessage('restore') or Chat.HasContinue or Self.CurrentPatch.IsEmpty), 15, 15000);
  end;

  Wait(159, 658);
end;

procedure TFarmRun.HandleDiseasedPatch();
begin
  Self.CurrentPatch.Skip := True;
end;

procedure TFarmRun.WithdrawCompost;
var
  withdrawAmt      : Int32 := Round(Inventory.CountEmptySlots * 0.2) + 1;
  leprechaunPt     : TPoint;
  boxes            : TBoxArray := [[160, 210, 245, 245],
                                   [275, 210, 360, 245],
                                   [390, 210, 475, 245],
                                   [390, 210, 475, 245],
                                   [  0,   0,   0,   0]];
begin
  if not RSClient.IsLoggedIn then
    Exit;

  if not Self.CurrentPatch.FindLeprechaun(leprechaunPt) then
    Exit;

  Mouse.Move(leprechaunPt);
  if not ChooseOption.Select('Exchange') then
    Exit;

  if not WaitUntil(MainScreen.HasInterface, 15, 15000) then
    Exit;

  if BankPin.IsOpen then
    BankPin.Enter(Login.GetPlayer.Pin);

  if SRL.CountColor(CTS2(2154272, 1, 0.01, 0.01), boxes[Self.CompostMethod]) = 0 then begin
    //TODO no green = no items
    //downgrade compost?
  end;

  Mouse.Move(boxes[Self.CompostMethod]);
  if withdrawAmt = 1 then begin
    ChooseOption.Select('Remove-1');
  end else if withdrawAmt = 5 then begin
    ChooseOption.Select('Remove-5');
  end else begin
    ChooseOption.Select('Remove-X');
    Chat.AnswerQuery('Enter amount', ToStr(withdrawAmt), 5000);
  end;

  MainScreen.CloseInterface(True);
end;

procedure TFarmRun.CompostPatch();
var
  compostArray    : TStringArray := ['Compost', 'Supercompost', 'Ultracompost', 'Bottomless compost bucket', ''];
  compostItem     : TRSItem := compostArray[Self.CompostMethod];
  slot, attempts  : Int32;
begin
  if not RSClient.IsLoggedIn then
    Exit;

  if not Self.CurrentPatch.Find then begin
    WriteLn('Couldn''t find patch to compost!');
    Exit;
  end;

  WriteLn('Composting at ' + Self.CurrentPatch.Data.Name + ' patch.');

  if (Self.CompostMethod <> ECompostMethod.FERTILE_SOIL) and (Inventory.GetSelectedSlot = -1) then begin
    if (not Inventory.FindItem(compostItem, slot)) and (Self.CompostMethod <> ECompostMethod.BOTTOMLESS) then begin
      WithdrawCompost;
      Inventory.FindItem(compostItem, slot);
      if not Self.CurrentPatch.Find then begin
        WriteLn('Couldn''t find patch to compost!');
        Exit;
      end;
    end;

    if (slot = -1) and (not (Inventory.FindItem(compostItem, slot))) then
      TerminateScript('Out of compost! Terminating.');
  end;

  if Self.CompostMethod = ECompostMethod.FERTILE_SOIL then begin
    if Magic.GetSpellBook <> ERSSpellBook.LUNAR then begin
      if SRL.Dice(80) then
        Antiban.LoseFocus
      else if SRL.Dice(50) then
        Antiban.RandomMouse
      else
        Magic.Open;
      Wait(130*ONE_SECOND); //wait for spellbook swap to timeout incase something broke.
      if Magic.GetSpellBook <> ERSSpellBook.LUNAR then
        TerminateScript('Not on the correct spellbook for fertilize soil!');
    end;

    Magic.ClickSpell(ERSSpell.FERTILE_SOIL);
  end else if (Inventory.GetSelectedSlot = -1) and (not Inventory.SetSelectedSlot(slot)) then begin
    WriteLn('Failed to select compost in inventory.');
    Exit;
  end;

  Wait(142, 379);

  for attempts := 0 to 2 do begin
    if attempts = 2 then begin
      WriteLn('Failed to find correct patch uptext while composting.');
      Antiban.RandomMouse;
      Wait(142, 379);
      Exit;
    end;

    if not Self.CurrentPatch.Find then
      Continue;

    if not Mainscreen.IsUpText(Self.CurrentPatch.PlantedUpText) then begin
      if SRL.Dice(65) then
        Mouse.HumanMove(SRL.RandomPoint(Self.CurrentPatch.TPA.Mean, Mainscreen.NormalizeDistance(15)))
      else
        Mouse.Move(SRL.RandomPoint(Self.CurrentPatch.TPA.Mean, Mainscreen.NormalizeDistance(15)));
    end;

    if MainScreen.IsUpText(Self.CurrentPatch.PlantedUpText) then begin
      Mouse.Click(MOUSE_LEFT);
      Break;
    end else if ChooseOption.Select(Self.CurrentPatch.PlantedUpText) then begin
      Break;
    end;
    Mouse.RandomMovement;
  end;

  if MainScreen.DidYellowClick then begin
    WriteLn('FOUND YELLOW CLICK!');
    Exit;
  end;

  if not WaitUntil((Chat.FindMessage('trea') or Chat.FindMessage('ming 2')), 50, 10000) then begin
    WriteLn('WaitUntil failed in composting step.');
    Exit;
  end;

  Wait(98, 178);
  Self.DropBuckets;

  if SRL.Dice(40) then begin
    Self.CleanGrimyHerbs;
    if SRL.Dice(80) then
      Self.NoteItems;
  end;

  Wait(208, 313);
  Self.CurrentPatch.Complete := True;
end;

procedure TFarmRun.Plant();
var
  slot, attempts  : Int32;
  compostArray    : TStringArray := ['Compost', 'Supercompost', 'Ultracompost', 'Bottomless compost bucket', ''];
  compostItem     : TRSItem := compostArray[Self.CompostMethod];
begin
  if not RSClient.IsLoggedIn then
    Exit;

  if not Self.CurrentPatch.Find then
    Exit;

  WriteLn('Planting ' + toStr(Self.CurrentPatch.Seed) + ' at ' + Self.CurrentPatch.Data.Name + ' patch.');

  //Inventory.FindItem(Self.CurrentPatch.Seed, slot)
  if Inventory.GetSelectedSlot = -1 then begin
    if not Inventory.FindItem(Self.CurrentPatch.Seed, slot) then begin
      WriteLn('Couldn''t find seed in inventory.');
      Exit;
    end;

    if not Inventory.SetSelectedSlot(slot) then begin
      WriteLn('Failed to select seed in inventory.');
      Exit;
    end;
  end;

  for attempts := 0 to 2 do begin
    if attempts = 2 then begin
      WriteLn('Failed to find correct patch uptext or choose option while planting.');
      Inventory.SetSelectedSlot(-1);
      Antiban.RandomMouse;
      Wait(142, 379);
      Exit;
    end;

    if not Self.CurrentPatch.Find then
      Continue;

    if not MainScreen.IsUpText(Self.CurrentPatch.EmptyUpText) then begin
      if SRL.Dice(65) then
        Mouse.HumanMove(SRL.RandomPoint(Self.CurrentPatch.TPA.Mean, Mainscreen.NormalizeDistance(15)))
      else
        Mouse.Move(SRL.RandomPoint(Self.CurrentPatch.TPA.Mean, Mainscreen.NormalizeDistance(15)));
    end;

    if (Self.CurrentPatch.Data.PatchType <> EPatchType.HERB)
     and (Self.CurrentPatch.PlantedUpText in MainScreen.GetUpText.After('>')) then begin
      if MainScreen.IsUpText(Self.CurrentPatch.HarvestUpText) then
        Self.Harvest
      else
        Self.CompostPatch;
      Exit;
    end;

    if MainScreen.IsUpText(Self.CurrentPatch.EmptyUpText) then begin
      Mouse.Click(MOUSE_LEFT);
      Break;
    end else if ChooseOption.Select(Self.CurrentPatch.EmptyUpText) then begin
      Break;
    end;

    Mouse.RandomMovement;
  end;

  if not MainScreen.DidRedClick then begin
    Exit;
  end;

  Wait(472, 617);
  Minimap.WaitPlayerMoving;
  Wait(472, 617);

  if Chat.HasContinue then begin
    if Self.CurrentPatch.Data.PatchType <> EPatchType.FLOWER then
      Self.CompostPatch
    else
      Self.CurrentPatch.Complete := True;
    Exit;
  end;

  if not Self.CurrentPatch.Find(False) then begin
    Exit;
  end;

  if Self.CurrentPatch.Data.PatchType <> EPatchType.FLOWER then begin
    if SRL.Dice(65) then begin
      if Self.CompostMethod = ECompostMethod.FERTILE_SOIL then
        //TODO
      else if Inventory.FindItem(compostItem, slot) then
        Inventory.SetSelectedSlot(slot);
      Wait(78, 208);
      if SRL.Dice(65) then
        Mouse.HumanMove(SRL.RandomPoint(Self.CurrentPatch.TPA.Mean, Mainscreen.NormalizeDistance(15)))
      else
        Mouse.Move(SRL.RandomPoint(Self.CurrentPatch.TPA.Mean, Mainscreen.NormalizeDistance(15)));
    end;
  end;

  if WaitUntil(((not Self.CurrentPatch.IsEmpty){ or Chat.FindMessage('ou plant')}), 15, 10000) then begin
    Wait(338, 562);
    if Self.CurrentPatch.Data.PatchType <> EPatchType.FLOWER then
      Self.CompostPatch
    else
      Self.CurrentPatch.Complete := True;
  end
end;

procedure TFarmRun.Harvest();
var
  i, slot         : Int32;
begin
  if not RSClient.IsLoggedIn then
    Exit;

  WriteLn('Harvesting at ' + Self.CurrentPatch.Data.Name + ' patch.');

  if Inventory.IsFull or (Self.CurrentPatch.Data.PatchType = EPatchType.FLOWER) then
    Self.NoteItems;

  Minimap.WaitPlayerMoving;
  if not Self.CurrentPatch.Find then
    Exit;

  if not Mainscreen.IsUpText(Self.CurrentPatch.HarvestUpText) then begin
    if SRL.Dice(65) then
      Mouse.HumanMove(SRL.RandomPoint(Self.CurrentPatch.TPA.Mean, Mainscreen.NormalizeDistance(15)))
    else
      Mouse.Move(SRL.RandomPoint(Self.CurrentPatch.TPA.Mean, Mainscreen.NormalizeDistance(15)));
  end;

  if Mainscreen.IsUpText(Self.CurrentPatch.HarvestUpText) then begin
    Mouse.Click(MOUSE_LEFT);
  end else if not ChooseOption.Select(Self.CurrentPatch.HarvestUpText) then begin
    WriteLn('Failed to find harvest uptext or choose option.');
    Exit;
  end;

  if not Mainscreen.DidRedClick then begin
    WriteLn('Failed to find red click.');
    Exit;
  end;

  Wait(742, 1129);
  Minimap.WaitPlayerMoving;
  Wait(352, 567);

  if not Self.CurrentPatch.Find(False) then
    Exit;

  if SRL.Dice(35) and Inventory.FindItem(Self.CurrentPatch.Seed, slot) then begin
    Inventory.SetSelectedSlot(slot);
    if SRL.Dice(65) then
      Mouse.HumanMove(SRL.RandomPoint(Self.CurrentPatch.TPA.Mean, Mainscreen.NormalizeDistance(15)))
    else
      Mouse.Move(SRL.RandomPoint(Self.CurrentPatch.TPA.Mean, Mainscreen.NormalizeDistance(15)));
  end;

  for i := 0 to (Inventory.CountEmptySlots * 8 + 8) do begin
    if Self.CurrentPatch.IsEmpty then begin
      Plant;
      Exit;
    end else if Inventory.IsFull then begin
      Inventory.SetSelectedSlot(-1);
      Self.NoteItems;
      Harvest;
    end;
    Wait(300);
  end;
end;

procedure TFarmRun.HarvestWhiteBerries();
var
  i        : Int32;
begin
  if not RSClient.IsLoggedIn then
    Exit;

  WriteLn('Harvesting whiteberries at ' + Self.CurrentPatch.Data.Name + ' patch.');

  if Inventory.IsFull then
    Self.NoteItems;

  if WaitUntil(Minimap.IsPlayerMoving, 17, 600) then
    while Minimap.IsPlayerMoving do
      Wait(13, 199);

  if not Self.CurrentPatch.Find then
    Exit;

  if not Mainscreen.IsUpText('Pick') then begin
    if SRL.Dice(65) then
      Mouse.HumanMove(SRL.RandomPoint(Self.CurrentPatch.TPA.Mean, Mainscreen.NormalizeDistance(15)))
    else
      Mouse.Move(SRL.RandomPoint(Self.CurrentPatch.TPA.Mean, Mainscreen.NormalizeDistance(15)));
  end;

  if Mainscreen.IsUpText('Clear') then begin
      Self.CurrentPatch.Complete := True;
      Exit;
  end;

    if Mainscreen.IsUpText('Pick') then begin
    Mouse.Click(MOUSE_LEFT);
  end else if MainScreen.IsUpText('Clear') then begin
    Self.CurrentPatch.Complete := True;
    Exit;
  end else if not ChooseOption.Select('Pick', MOUSE_LEFT, True, False) then begin
    if ChooseOption.HasOption('Clear') then begin
      Self.CurrentPatch.Complete := True
    end else begin
      WriteLn('Failed to find harvest uptext or choose option.');
    end;
    Exit;
  end;

  if not Mainscreen.DidRedClick then begin
    WriteLn('Failed to find red click.');
    Exit;
  end;

  if WaitUntil(Minimap.IsPlayerMoving, 17, 600) then
    while Minimap.IsPlayerMoving do
      Wait(13, 199);

  if not Self.CurrentPatch.Find(False) then
    Exit;

  if SRL.Dice(65) then
    Mouse.HumanMove(SRL.RandomPoint(Self.CurrentPatch.TPA.Mean, Mainscreen.NormalizeDistance(15)))
  else
    Mouse.Move(SRL.RandomPoint(Self.CurrentPatch.TPA.Mean, Mainscreen.NormalizeDistance(15)));

  for i := 0 to (Inventory.CountEmptySlots * 8 + 8) do begin
    if Mainscreen.IsUpText('ear') then begin
      Self.CurrentPatch.Complete := True;
      Exit;
    end else if Inventory.IsFull then begin
      Inventory.SetSelectedSlot(-1);
      Self.NoteItems;
      HarvestWhiteBerries;
    end;
    Wait(300);
  end;
end;

procedure TFarmRun.UsePOHSpiritTree(Location: String);
var
  Primary, Secondary,
  TPA                 : TPointArray;
  ATPA                : T2DPointArray;
begin

  if not WaitUntil(Minimap.InPOH, 15, 15000) then begin
    WriteLn('Not in POH!');
    Exit;
  end;

  for 1 to 3 do begin
    if (SRL.FindColors(Primary, CTS2(1649718, 5, 0.15, 1.14), MainScreen.Bounds) = 0)
     or (SRL.FindColors(Secondary, CTS2(1720892, 10, 0.21, 1.42), MainScreen.Bounds) = 0) then begin
      if SRL.Dice(50) then
        MiniMap.SetCompassAngle(Random(106, 153))
      else
        MiniMap.SetCompassAngle(Random(209, 248));
      Continue;
    end;

    TPA := Primary.PointsInRangeOf(Secondary, 0, MainScreen.NormalizeDistance(38));

    TPA.Grow(MainScreen.NormalizeDistance(8));
    TPA.Erode(MainScreen.NormalizeDistance(6));

    if TPA = [] then begin
      if SRL.Dice(50) then
        MiniMap.SetCompassAngle(Random(106, 153))
      else
        MiniMap.SetCompassAngle(Random(209, 248));
    end;
  end;

  if TPA = [] then begin
    WriteLn('Failed to find spirit tree. Skipping.');
    Self.CurrentPatch.Skip := True;
    Exit;
  end;

  ATPA := TPA.Cluster(MainScreen.NormalizeDistance(18));
  ATPA.SortBySize;

  if SRL.Dice(65) then
    Mouse.HumanMove(SRL.RandomPoint(ATPA[0].Mean, MainScreen.NormalizeDistance(20)))
  else
    Mouse.Move(SRL.RandomPoint(ATPA[0].Mean, MainScreen.NormalizeDistance(20)));

  if MainScreen.IsUpText('Spirit') then
    Mouse.Click(MOUSE_LEFT)
  else if not ChooseOption.Select('Travel') then begin
    WriteLn('Failed to find spirit tree uptext!');
    Self.CurrentPatch.Skip := True;
    Exit;
  end;

  if SRL.Dice(66) then begin
    Wait(718, 2168);
    case Location of
      'guild': KeyBoard.KeyDown(VK_B);
    end;
  end;

  if not WaitUntil(MainScreen.HasInterface, 15, 10000) then begin
    WriteLn('Timed out waiting for spirit tree interface.');
    Exit;
  end;

  if not KeyBoard.IsKeyDown(VK_B) then
    KeyBoard.PressKey(VK_B);

  WaitUntil((not Minimap.InPOH), 15, 10000);
  KeyBoard.KeyUp(VK_B);
end;

procedure TFarmRun.TeleportTo();
label
  teleport_complete;
var
  item            : TRSItem         := '';
  spell           : ERSSpell        := ERSSpell.BAKE_PIE;
  b: TBox;
begin
  if not RSClient.IsLoggedIn then
    Exit;

  Inventory.SetSelectedSlot(-1);

  if Minimap.InPOH then begin

    case Self.CurrentPatch.TravelMethod of
      ETravelMethod.HOUSE_TAB_SPIRIT_TREE_GUILD,
      ETravelMethod.HOUSE_TELE_SPIRIT_TREE_GUILD:
        begin
          Self.UsePOHSpiritTree('guild');
          goto teleport_complete;
        end;
    end;
  end;

  if Self.RSW.GetMyPos in Self.CurrentPatch.Data.MapCoords then begin
    Exit;
  end;

  case Self.CurrentPatch.TravelMethod of
    ETravelMethod.ICY_BASALT:
      begin
        item := 'Icy basalt';
        wait(250,500);
        Inventory.ClickItem(item, 'Weiss');
      end;
    ETravelMethod.STONY_BASALT:
      begin
        item := 'Stony basalt';
        wait(250,500);
        Inventory.ClickItem(item, 'Stronghold');
      end;
    ETravelMethod.CATHERBY_TABLET:
      begin
        item := 'Catherby teleport';
        wait(250,500);
        Inventory.ClickItem(item, 'Break');
      end;
    ETravelMethod.CATHERBY_TELEPORT:
      begin
        spell := ERSSpell.CATHERBY_TELEPORT;
        wait(250,500);
        Magic.CastSpell(spell, 'Cast');
      end;
    ETravelMethod.CAMELOT_TELEPORT:
      begin
        spell := ERSSpell.CAMELOT_TELEPORT;
        wait(250,500);
        Magic.CastSpell(spell, 'Cast');
      end;
    ETravelMethod.CAMELOT_TABLET:
      begin
        item := 'Camelot teleport';
        wait(250,500);
        Inventory.ClickItem(item, 'Break');
      end;
    ETravelMethod.FENKENSTRAIN_TELEPORT:
      begin
        spell := ERSSpell.FENKENSTRAINS_CASTLE_TELEPORT;
        wait(250,500);
        Magic.ClickSpell(spell);
      end;
    ETravelMethod.ECTOPHIAL:
      begin
        item := 'Ectophial';
        wait(250,500);
        Inventory.ClickItem(item, 'Empty');
        wait(4000,5000);
      end;
    ETravelMethod.XERICS_TALISMAN:
      begin
        item := 'Xeric''s talisman';
        wait(250,500);
        if Inventory.ContainsItem('Xeric''s talisman') then
        begin
          Inventory.ClickItem(item, 'Rub');
          WaitUntil(Mainscreen.HasInterface(), 10, 5000);
          b := ([219,92,293,101]);
          Mouse.Click(b, MOUSE_LEFT);
        end
        else
          Equipment.ClickItem(item, 'Xeric''s Glade');
      end;
    ETravelMethod.HOSIDIOUS_TABLET:
      begin
        item := 'Hosidius teleport';
        wait(250,500);
        Inventory.ClickItem(item, 'Break');
      end;
    ETravelMethod.HOUSE_TELEPORT:
      begin
        item := 'Teleport to house';
        wait(250,500);
        if Inventory.ContainsItem('Teleport to house') then
        begin
          Inventory.ClickItem(item, 'Outside');
        end
        else
          Magic.CastSpell(ERSSpell.TELEPORT_TO_HOUSE, 'Outside');
      end;
    ETravelMethod.FARMING_CAPE:
      begin
        item := 'Farming cape';
        wait(250,500);
        if not Equipment.ClickItem(item, 'Teleport') then
          Inventory.ClickItem(item, 'Teleport');
      end;
    ETravelMethod.EXPLORERS_RING_2:
      begin
        item := 'Explorer''s ring 2';
        wait(250,500);
        if not Inventory.ClickItem(item, 'Teleport') then
          Equipment.ClickItem(item, 'Teleport');
      end;
    ETravelMethod.EXPLORERS_RING_3:
      begin
        item := 'Explorer''s ring 3';
        wait(250,500);
        if not Inventory.ClickItem(item, 'Teleport') then
          Equipment.ClickItem(item, 'Teleport');
      end;
    ETravelMethod.EXPLORERS_RING_4:
      begin
        item := 'Explorer''s ring 4';
        wait(250,500);
        if not Inventory.ClickItem(item, 'Teleport') then
          Equipment.ClickItem(item, 'Teleport');
      end;
    ETravelMethod.ARDY_CLOAK_2:
      begin
        item := 'Ardougne cloak 2';
        wait(250,500);
        if not Inventory.ClickItem(item, 'Farm Teleport') then
          Equipment.ClickItem(item, 'Ardougne Farm');
      end;
    ETravelMethod.ARDY_CLOAK_2_BUSH:
      begin
        item := 'Ardougne cloak 2';
        wait(250,500);
        if not Inventory.ClickItem(item, 'Monastery Teleport') then
          Equipment.ClickItem(item, 'Kandarin Monastery');
      end;
    ETravelMethod.ARDY_CLOAK_3:
      begin
        item := 'Ardougne cloak 3';
        wait(250,500);
        if not Inventory.ClickItem(item, 'Farm Teleport') then
          Equipment.ClickItem(item, 'Ardougne Farm');
      end;
    ETravelMethod.ARDY_CLOAK_3_BUSH:
      begin
        item := 'Ardougne cloak 3';
        wait(250,500);
        if not Inventory.ClickItem(item, 'Monastery Teleport') then
          Equipment.ClickItem(item, 'Kandarin Monastery');
      end;
    ETravelMethod.ARDY_CLOAK_4:
      begin
        item := 'Ardougne cloak 4';
        wait(250,500);
        if not Inventory.ClickItem(item, 'Farm Teleport') then
          Equipment.ClickItem(item, 'Ardougne Farm');
      end;
    ETravelMethod.ARDY_CLOAK_4_BUSH:
      begin
        item := 'Ardougne cloak 4';
        wait(250,500);
        if not Inventory.ClickItem(item, 'Monastery Teleport') then
          Equipment.ClickItem(item, 'Kandarin Monastery');
      end;
    ETravelMethod.HOUSE_TAB_SPIRIT_TREE_GUILD:
      begin
        item := 'Teleport to house';
        wait(250,500);
        Inventory.ClickItem(item, 'Break');
      end;
    ETravelMethod.HOUSE_TELE_SPIRIT_TREE_GUILD:
      begin
        spell := ERSSpell.TELEPORT_TO_HOUSE;
        wait(250,500);
        Magic.CastSpell(spell);
      end;
  end;

  Wait(548, 732); Wait(118, 278);

  if ('Ardougne' in item) then begin
    if Chat.FindMessage('cape has recharged') then begin
      WriteLn('Out of ardy cape charges. Skipping patch.');
      Self.CurrentPatch.Skip := True;
      Exit;
    end;
  end else if ('Explorer' in item) then begin
    if Chat.FindMessage('ring recharges') then begin
      WriteLn('Out of explorer''s ring charges. Skipping patch.');
      Self.CurrentPatch.Skip := True;
      Exit;
    end;
  end else if Self.CurrentPatch.TravelMethod = ETravelMethod.XERICS_TALISMAN then begin
    if Equipment.ContainsItem('Xeric''s talisman (inert)') then begin
      WriteLn('Out of xeric''s talisman charges. Skipping patch.');
      Self.CurrentPatch.Skip := True;
      Exit;

    end else if ((not Equipment.ContainsItem('Xeric''s talisman')) and (not Inventory.ContainsItem('Xeric''s talisman'))) then begin
      WriteLn('No xeric''s talisman equipped. Skipping patch.');
      Self.CurrentPatch.Skip := True;
      Exit;
    end;

  end else if spell <> ERSSpell.BAKE_PIE then begin
    if Chat.FindMessage('to cast') then begin
      WriteLn('Out of runes for ' + ToStr(spell) + '. Skipping patch.');
      Self.CurrentPatch.Skip := True;
      Exit;
    end;
  end;

  if (Self.CurrentPatch.TravelMethod = ETravelMethod.HOUSE_TAB_SPIRIT_TREE_GUILD)
    or (Self.CurrentPatch.TravelMethod = ETravelMethod.HOUSE_TELE_SPIRIT_TREE_GUILD) then
      Self.UsePOHSpiritTree('guild');

  teleport_complete:
  if not WaitUntil((Self.RSW.GetMyPos in Self.CurrentPatch.Data.MapCoords), 10, 10000) then
    Exit;

  if (SRL.Dice(75) and (Inventory.CountEmptySlots <= 6)) or Inventory.IsFull then
    Self.NoteItems;
end;

procedure TFarmRun.DropBuckets();
var
  Tmp, Slots : TIntegerArray;
  I : Int32;
begin
  if not Inventory.FindItems(['Bucket'], Tmp) then
    Exit;

  for I := 0 to High(Tmp) do begin
    if SRL.CountColor(CTS2(4087132, 1, 3.61, 4.36), Inventory.GetSlotBox(Tmp[I])) > 2 then
      Continue
    else
      Slots += Tmp[I];
  end;

  if Slots.Len < 1 then
    Exit;

  Inventory.ShiftDrop(Slots);
end;

procedure TFarmRun.Report();
var
  strings                   : TStringArray;
  variants                  : TVariantArray;
  i                         : Int32;
begin
  strings := [{'Runtime', 'Xp gained', 'Xp per hour', }'Runs complete'];
  variants := [
  //{runtime}         SRL.MsToTime(Self.Runtime.ElapsedTime, Time_Short),
  //{xp gained}       ToStr(Self.XPGained),
  //{xp per hour}     NumberPerHour(Self.XPGained, Self.Runtime.ElapsedTime),
  {runs complete}   Self.RunsComplete];

  for i:= 0 to High(LEPRECHAUN_ITEMS) do begin
    if Self.HarvestQuantities[i] > 0 then begin
      strings += LEPRECHAUN_ITEMS[i];
      variants += Self.HarvestQuantities[i];
    end;
  end;

  ProgReport(1, 'Farm Run Progress Report','Club XJ', '', strings, variants);
end;

procedure TFarmRun.Init();
var
  tmp: TBoxArray;
  i: Int32;
begin
  if not RSClient.IsLoggedIn then
    Login.LoginPlayer;

  for i := 0 to High(Self.Patches) do
    tmp += Self.Patches[i].Data.MapCoords;

  ItemFinder.Similarity := 0.997;

  Self.RSW.SetupRegions(tmp);
  Self.RSW.AdaptiveWalk := True;

  Self.InactivityTimer.Init(3*ONE_MINUTE);
  ReadyTimer.Init(Random(86*ONE_MINUTE, 97*ONE_MINUTE));

  SetLength(Self.HarvestQuantities, Length(LEPRECHAUN_ITEMS));
end;

procedure TFarmRun.Run();
var
  state           : EPatchState;
  failedCount     : Int32;
  AntibanMinZ, AntibanMaxZ: Int32;
begin
  if not RSClient.IsLoggedIn then
    Login.LoginPlayer;

  Antiban.DebugLn('Starting farm run.');
  Self.Runtime.Start;

  AntibanMinZ := Antiban.MinZoom;
  AntibanMaxZ := Antiban.MaxZoom;
  Antiban.MinZoom := 17;
  Antiban.MaxZoom := 23;
  Mainscreen.SetHighestPitch;
  Options.SetZoomLevel(Random(17, 23));

  if @Self.OnStart <> nil then
    Self.OnStart;

  Self.LastXPRead := XPBar.Read;
  Self.InactivityTimer.Restart;

  if not RSClient.IsLoggedIn then
    Login.LoginPlayer;

  for Self.CurrentPatch in Self.Patches do begin
    if not RSClient.IsLoggedIn then
      Login.LoginPlayer;

    repeat
      state := Self.CurrentPatch.GetState;

      if failedCount = 8 then
        state := EPatchState.SKIP;

      if state <> EPatchState.FAILED then
        failedCount := 0;

      case state of
        EPatchState.HARVEST_WHITEBERRIES: Self.HarvestWhiteBerries;
        EPatchState.HARVEST     : Self.Harvest;
        EPatchState.PLANT       : Self.Plant;
        EPatchState.COMPOST     : Self.CompostPatch;
        EPatchState.DISEASED    : Self.HandleDiseasedPatch;
        EPatchState.DEAD        : Self.HandleDeadPatch;
        EPatchState.TELEPORT_TO : Self.TeleportTo;
        EPatchState.NOTE_ITEMS  : Self.NoteItems;
        EPatchState.FAILED      : Inc(failedCount);
        EPatchState.COMPLETE    :
          begin
            WriteLn('Patch complete.');
            Inc(Self.PatchesCompleted);
            Break;
          end;
        EPatchState.SKIP        :
          begin
            WriteLn('Skipping patch.');
            Inc(Self.PatchesSkipped);
            Break;
          end;
      end;

      if XPBar.EarnedXP then
        InactivityTimer.Restart;

    until InactivityTimer.IsFinished;

    Self.CurrentPatch.Skip := Self.CurrentPatch.Complete := False;
    if Self.DoReport then
      Self.Report;
  end;

  if InactivityTimer.IsFinished then
    TerminateScript('Terminating due to inactivity.');

  Inc(Self.RunsComplete);

  Antiban.MinZoom := AntibanMinZ;
  Antiban.MaxZoom := AntibanMaxZ;

  if (@Self.OnComplete <> nil) then
    Self.OnComplete;

  Self.Runtime.Pause;

  Self.XPGained += XPBar.Read - Self.LastXPRead;
  Self.Report;
end;

procedure TFarmRun.DoFarmRun() begin

  if not ReadyTimer.IsFinished then begin
    //WriteLn('Next farm run in ' + ToStr(Round(Self.ReadyTimer.TimeRemaining() / ONE_MINUTE)) + ' minutes.');
    Exit;
  end;

  Self.Run;

  ReadyTimer.Init(Random(86*ONE_MINUTE, 97*ONE_MINUTE));

end;
